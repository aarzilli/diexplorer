// This script generates frame_opcodes.go from frame_opcodes.txt

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strconv"
	"strings"
)

type Opcode struct {
	Name   string
	High2  string
	Low6   string
	Opcode uint8
	Args   string
}

func removeEmpty(s []string) []string {
	r := []string{}
	for i := range s {
		if s[i] != "" {
			r = append(r, s[i])
		}
	}
	return r
}

func main() {
	fh, err := os.Open(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}
	defer fh.Close()

	outfh := os.Stdout
	if os.Args[2] != "-" {
		outfh, err = os.Create(os.Args[2])
		if err != nil {
			log.Fatal(err)
		}
		defer outfh.Close()
	}

	opcodes := []Opcode{}
	s := bufio.NewScanner(fh)
	for s.Scan() {
		line := strings.TrimSpace(s.Text())
		if line == "" || strings.HasPrefix(line, "//") {
			continue
		}
		fields := removeEmpty(strings.Split(line, "\t"))
		opcode := Opcode{Name: fields[0], High2: fields[1], Low6: fields[2], Args: fields[3]}
		high2, _ := strconv.ParseInt(opcode.High2, 0, 8)
		low6, _ := strconv.ParseInt(opcode.Low6, 0, 8)
		opcode.Opcode = uint8(high2<<6 | low6)
		opcodes = append(opcodes, opcode)
	}

	var buf bytes.Buffer

	fmt.Fprintf(&buf, `// THIS FILE IS AUTOGENERATED, EDIT frame_opcodes.txt INSTEAD
	
package main
`)

	// high2 map
	fmt.Fprintf(&buf, "var frameOpcodeHigh2 = map[uint8]string{\n")
	for _, opcode := range opcodes {
		if opcode.High2 != "0" {
			fmt.Fprintf(&buf, "%s: %q,\n", opcode.High2, opcode.Name)
		}
	}
	fmt.Fprintf(&buf, "}\n")

	// low 6 map
	fmt.Fprintf(&buf, "var frameOpcodeLow6 = map[uint8]string{\n")
	for _, opcode := range opcodes {
		if opcode.High2 == "0" {
			fmt.Fprintf(&buf, "%s: %q,\n", opcode.Low6, opcode.Name)
		}
	}
	fmt.Fprintf(&buf, "}\n")

	// arguments map
	fmt.Fprintf(&buf, "var frameOpcodeArgs = map[uint8]string{\n")
	for _, opcode := range opcodes {
		fmt.Fprintf(&buf, "%#x: %s,\n", opcode.Opcode, opcode.Args)
	}
	fmt.Fprintf(&buf, "}\n")

	src, err := format.Source(buf.Bytes())
	if err != nil {
		outfh.Write(buf.Bytes())
		log.Fatal(err)
	} else {
		outfh.Write(src)
	}

}
